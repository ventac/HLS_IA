"""
extract_weights.py

Reads FLOAT/lenet_weights.weights.h5 and writes C source file
FIXED/lenet_weights_data.c and header FIXED/lenet_weights_data.h which
contain static float arrays for all network weights and biases in the
same layout expected by the C code in this repository.

Usage: python3 tools/extract_weights.py [path/to/lenet_weights.weights.h5]

The script preserves the array ordering used by the existing C readers
(i.e. kernel shapes and re-ordering matching Read* functions).
"""
from __future__ import print_function
import sys
import os
import numpy as np
import h5py

# Defaults
REPO_ROOT = os.path.dirname(os.path.dirname(__file__))
H5_PATH = os.path.join(REPO_ROOT, 'FLOAT', 'lenet_weights.weights.h5')
OUT_C = os.path.join(REPO_ROOT, 'FIXED', 'lenet_weights_data.c')
OUT_H = os.path.join(REPO_ROOT, 'FIXED', 'lenet_weights_data.h')

if __name__ == '__main__':
    if len(sys.argv) > 1:
        H5_PATH = sys.argv[1]

    if not os.path.exists(H5_PATH):
        print('Error: HDF5 file not found at', H5_PATH)
        sys.exit(1)

    f = h5py.File(H5_PATH, 'r')
    # Layer datasets used by the C code
    datasets = {
        'conv1_w': '/layers/conv2d/vars/0',
        'conv1_b': '/layers/conv2d/vars/1',
        'conv2_w': '/layers/conv2d_1/vars/0',
        'conv2_b': '/layers/conv2d_1/vars/1',
        'fc1_w'  : '/layers/dense/vars/0',
        'fc1_b'  : '/layers/dense/vars/1',
        'fc2_w'  : '/layers/dense_1/vars/0',
        'fc2_b'  : '/layers/dense_1/vars/1',
    }

    data = {}
    for key, path in datasets.items():
        if path not in f:
            print('Warning: dataset', path, 'not found in HDF5 file')
            data[key] = None
            continue
        data[key] = np.array(f[path])
        print('Read', key, 'shape', data[key].shape)

    f.close()

    # Helper to format numpy arrays as C initializers
    def c_array(name, arr, dtype='float'):
        flat = arr.ravel()
        lines = []
        per_line = 8
        for i in range(0, len(flat), per_line):
            chunk = flat[i:i+per_line]
            lines.append(', '.join(('%0.8ff' % float(x)).rstrip('0').rstrip('.') + 'f' if False else ('%0.8ff' % float(x)) for x in chunk))
        return ',\n    '.join(lines)

    # We'll write a header with extern declarations and a C file with data
    with open(OUT_H, 'w') as h:
        h.write('/* Generated by tools/extract_weights.py - do not edit */\n')
        h.write('#ifndef LENET_WEIGHTS_DATA_H\n#define LENET_WEIGHTS_DATA_H\n\n')
        h.write('#include "lenet_cnn_float.h"\n\n')
        h.write('/* Declarations for compiled-in weights */\n')
        h.write('extern float CONV1_KERNEL[CONV1_NBOUTPUT][IMG_DEPTH][CONV1_DIM][CONV1_DIM];\n')
        h.write('extern float CONV1_BIAS[CONV1_NBOUTPUT];\n')
        h.write('extern float CONV2_KERNEL[CONV2_NBOUTPUT][POOL1_NBOUTPUT][CONV2_DIM][CONV2_DIM];\n')
        h.write('extern float CONV2_BIAS[CONV2_NBOUTPUT];\n')
        h.write('extern float FC1_KERNEL[FC1_NBOUTPUT][POOL2_NBOUTPUT][POOL2_HEIGHT][POOL2_WIDTH];\n')
        h.write('extern float FC1_BIAS[FC1_NBOUTPUT];\n')
        h.write('extern float FC2_KERNEL[FC2_NBOUTPUT][FC1_NBOUTPUT];\n')
        h.write('extern float FC2_BIAS[FC2_NBOUTPUT];\n')
        h.write('\n#endif /* LENET_WEIGHTS_DATA_H */\n')

    with open(OUT_C, 'w') as c:
        c.write('/* Generated by tools/extract_weights.py - do not edit */\n')
        c.write('#include "lenet_weights_data.h"\n')
        c.write('\n')

        # CONV1: Keras stores conv kernels as (kh, kw, in_ch, out_ch)
        if data['conv1_w'] is not None:
            conv1 = data['conv1_w']  # shape (5,5,1,20)
            # Reorder to [out_ch][in_ch][kh][kw]
            conv1_re = np.transpose(conv1, (3, 2, 0, 1))
            c.write('float CONV1_KERNEL[CONV1_NBOUTPUT][IMG_DEPTH][CONV1_DIM][CONV1_DIM] = {\n')
            for k in range(conv1_re.shape[0]):
                c.write('  {\n')
                for z in range(conv1_re.shape[1]):
                    c.write('    {\n')
                    for y in range(conv1_re.shape[2]):
                        c.write('      { ')
                        row = ', '.join('%0.8ff' % float(x) for x in conv1_re[k, z, y, :])
                        c.write(row)
                        c.write(' },\n')
                    c.write('    },\n')
                c.write('  },\n')
            c.write('};\n\n')
        else:
            c.write('/* CONV1_KERNEL: not generated - dataset missing */\n\n')

        if data['conv1_b'] is not None:
            cb = data['conv1_b']
            c.write('float CONV1_BIAS[CONV1_NBOUTPUT] = { ')
            c.write(', '.join('%0.8ff' % float(x) for x in cb))
            c.write(' };\n\n')
        else:
            c.write('/* CONV1_BIAS: not generated - dataset missing */\n\n')

        if data['conv2_w'] is not None:
            conv2 = data['conv2_w']  # shape (5,5,20,40)
            conv2_re = np.transpose(conv2, (3, 2, 0, 1))
            c.write('float CONV2_KERNEL[CONV2_NBOUTPUT][POOL1_NBOUTPUT][CONV2_DIM][CONV2_DIM] = {\n')
            for k in range(conv2_re.shape[0]):
                c.write('  {\n')
                for z in range(conv2_re.shape[1]):
                    c.write('    {\n')
                    for y in range(conv2_re.shape[2]):
                        c.write('      { ')
                        row = ', '.join('%0.8ff' % float(x) for x in conv2_re[k, z, y, :])
                        c.write(row)
                        c.write(' },\n')
                    c.write('    },\n')
                c.write('  },\n')
            c.write('};\n\n')
        else:
            c.write('/* CONV2_KERNEL: not generated - dataset missing */\n\n')

        if data['conv2_b'] is not None:
            cb = data['conv2_b']
            c.write('float CONV2_BIAS[CONV2_NBOUTPUT] = { ')
            c.write(', '.join('%0.8ff' % float(x) for x in cb))
            c.write(' };\n\n')
        else:
            c.write('/* CONV2_BIAS: not generated - dataset missing */\n\n')

        if data['fc1_w'] is not None:
            # Keras dense weights shape: (in_units, out_units) where in_units = POOL2_NBOUTPUT*POOL2_HEIGHT*POOL2_WIDTH
            fc1 = data['fc1_w']  # shape (640,400)
            # C expects FC1_KERNEL[FC1_NBOUTPUT][POOL2_NBOUTPUT][POOL2_HEIGHT][POOL2_WIDTH]
            # We need to map flatten index -> (y,x,z) as used in ReadFc1Weights
            in_units, out_units = fc1.shape
            assert out_units == 400
            # Reshape input axis into (y,x,z) in order y,x,z where
            # in_units == POOL2_HEIGHT*POOL2_WIDTH*POOL2_NBOUTPUT
            POOL2_H = 8
            POOL2_W = 8
            POOL2_C = 40
            assert in_units == POOL2_H * POOL2_W * POOL2_C
            fc1_reshaped = fc1.reshape((POOL2_H, POOL2_W, POOL2_C, out_units))
            # Now reorder to [out][z][y][x]
            fc1_re = np.transpose(fc1_reshaped, (3, 2, 0, 1))
            c.write('float FC1_KERNEL[FC1_NBOUTPUT][POOL2_NBOUTPUT][POOL2_HEIGHT][POOL2_WIDTH] = {\n')
            for k in range(fc1_re.shape[0]):
                c.write('  {\n')
                for z in range(fc1_re.shape[1]):
                    c.write('    {\n')
                    for y in range(fc1_re.shape[2]):
                        c.write('      { ')
                        row = ', '.join('%0.8ff' % float(x) for x in fc1_re[k, z, y, :])
                        c.write(row)
                        c.write(' },\n')
                    c.write('    },\n')
                c.write('  },\n')
            c.write('};\n\n')
        else:
            c.write('/* FC1_KERNEL: not generated - dataset missing */\n\n')

        if data['fc1_b'] is not None:
            cb = data['fc1_b']
            c.write('float FC1_BIAS[FC1_NBOUTPUT] = { ')
            c.write(', '.join('%0.8ff' % float(x) for x in cb))
            c.write(' };\n\n')
        else:
            c.write('/* FC1_BIAS: not generated - dataset missing */\n\n')

        if data['fc2_w'] is not None:
            # shape (400,10) -> C expects [10][400]
            fc2 = data['fc2_w']
            c.write('float FC2_KERNEL[FC2_NBOUTPUT][FC1_NBOUTPUT] = {\n')
            for k in range(fc2.shape[1]):
                c.write('  { ')
                row = ', '.join('%0.8ff' % float(x) for x in fc2[:, k])
                c.write(row)
                c.write(' },\n')
            c.write('};\n\n')
        else:
            c.write('/* FC2_KERNEL: not generated - dataset missing */\n\n')

        if data['fc2_b'] is not None:
            cb = data['fc2_b']
            c.write('float FC2_BIAS[FC2_NBOUTPUT] = { ')
            c.write(', '.join('%0.8ff' % float(x) for x in cb))
            c.write(' };\n\n')
        else:
            c.write('/* FC2_BIAS: not generated - dataset missing */\n\n')

    print('Wrote', OUT_C)
    print('Wrote', OUT_H)
*** End Patch